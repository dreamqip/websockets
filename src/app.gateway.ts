import {
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, UsePipes } from '@nestjs/common';
import { AppService } from './app.service';
import { BatchValidationPipe } from './pipes/batch-validation.pipe';
import {
  BatchResponse,
  Chunk,
  ClientToServerEvents,
  ServerToClientEvents,
} from '@/utils/interfaces/chunk.interface';
import { SOCKET_EVENTS } from '@/utils/constants';
import { ChunkSchema } from '@/utils/schemas/chunkSchema';
import { SessionService } from '@/session/session.service';

@WebSocketGateway(8080)
export class AppGateway implements OnGatewayConnection, OnGatewayDisconnect {
  private readonly logger = new Logger(AppGateway.name);

  @WebSocketServer()
  server: Server = new Server<ServerToClientEvents, ClientToServerEvents>();

  constructor(
    private appService: AppService,
    private sessionService: SessionService,
  ) {}

  // there should be guard against invalid connection requests
  async handleConnection(client: Socket): Promise<void> {
    // client id is a random string generated by socket.io
    this.logger.log(`client connected with id ${client.id}`);
    // socket.io client handshake object contains the public key (not implemented yet)
    // client.handshake.auth.publicKey;
    // await this.sessionService.createSessionById(1);
    const sequenceNumber = this.appService.getSequenceNumber();
    client.emit('connection', {
      timestamp: Date.now(),
      sequence_number: sequenceNumber,
    });
  }

  @UsePipes(new BatchValidationPipe(ChunkSchema))
  @SubscribeMessage('send_batch')
  async handleEvent(@MessageBody() data: Chunk): Promise<void> {
    this.logger.log('batch received');
    this.appService.incrementSequenceNumber();
    let response: BatchResponse;

    const sequenceNumber = this.appService.getSequenceNumber();

    // if ('errors' in data) {
    //   response = {
    //     event: SOCKET_EVENTS.BATCH_REJECTED,
    //     original_timestamp: 'timestamp' in data ? data.timestamp : Date.now(),
    //     original_sequence_number:
    //       'sequence_number' in data ? data.sequence_number : sequenceNumber,
    //     server_timestamp: Date.now(),
    //     server_sequence_number: sequenceNumber,
    //   };
    // } else {
    // eslint-disable-next-line prefer-const
    response = {
      event: SOCKET_EVENTS.BATCH_ACCEPTED,
      original_timestamp: data.timestamp,
      original_sequence_number: data.sequence_number,
      server_timestamp: Date.now(),
      server_sequence_number: sequenceNumber,
    };
    // write to database
    await this.appService.writeChunkToDatabase(data);
    // }

    this.server.emit('batch_response', response);
  }

  handleDisconnect(client: Socket): void {
    this.logger.log('client disconnected');
    const sequenceNumber = this.appService.getSequenceNumber();
    client.emit('disconnection', {
      timestamp: Date.now(),
      sequence_number: sequenceNumber,
    });
    this.appService.resetSequenceNumber();
  }
}
